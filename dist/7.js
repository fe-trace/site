(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{147:function(n,e,i){"use strict";i.r(e),e.default="<h2 id=\"webpackoptimization\">webpack optimization 配置</h2>\n<h3 id=\"\">概述</h3>\n<p>optimization 选项用于配置和重写 webpack 默认的 chunk 生成方式</p>\n<h3 id=\"-1\">默认配置</h3>\n<pre><code>module.exports = {\n  optimization: {\n    splitChunks: {\n      // 需要优化的模块来源：async-异步加载的模块，initial-从配置入口引用的模块，all-包含上述两者\n      chunks: 'async',\n      // 将模块拆分成chunk的最小体积，体积过小不会拆分，避免出现很多小的模块\n      minSize: 30000,\n      // 和minSize含义相反\n      maxSize: 0,\n      // 模块被引用的最少次数\n      minChunks: 1,\n      // 异步模块动态加载JS的最大个数，如果满足多个规则，但是拆分数量大于请求数，只会拆分体积大的模块\n      maxAsyncRequests: 5,\n      // 入口模块的并行加载JS最大请求数，如果满足多个规则，但是拆分数量大于请求数，只会拆分体积大的模块\n      maxInitialRequests: 3,\n      // 生成bundle文件名的模块来源和名称之间的定界符(entry ~ module.js)\n      automaticNameDelimiter: '~',\n      // 生成 bundle 文件名的最大字符数\n      automaticNameMaxLength: 30,\n      // 生成bundle的名称,true：基于chunk生成名称\n      name: true,\n      // 缓存组，继承上诉规则并重新配置，默认提供来了default和vendors两个规则\n      cacheGroups: {\n        vendors: {\n          // 匹配具体的文件路径\n          test: /[\\\\/]node_modules[\\\\/]/,\n          // 拆分规则对应的权重，数组越大，生成规则越靠前\n          priority: -10\n        },\n        default: {\n          // 模块被引用的最小次数\n          minChunks: 2,\n          priority: -20,\n          reuseExistingChunk: true\n        }\n      }\n    }\n  }\n};\n</code></pre>\n<h3 id=\"-2\">实践</h3>\n<pre><code>optimization: {\n  // 拆分 webpack 实现模块加载相关代码\n  runtimeChunk: {\n    name: 'manifest'\n  },\n  splitChunks: {\n    cacheGroups: {\n      // 抽离第三方插件\n      lib: {\n        // 指定是node_modules下的第三方包\n        test: /node_modules/,\n        chunks: 'all',\n        // 设置优先级，防止和自定义的公共代码提取时被覆盖，不进行打包\n        priority: 10\n      },\n      // 抽离公共代码\n      commons: { \n        chunks: 'all',\n        minChunks: 2,\n        // 只要超出0字节就生成一个新包\n        minSize: 0\n      },\n      // 抽离入口模块，可以不配置这个\n      runtime: { \n        chunks: 'initial',\n        minSize: 0\n      }\n    }\n  }\n}\n</code></pre>"}}]);